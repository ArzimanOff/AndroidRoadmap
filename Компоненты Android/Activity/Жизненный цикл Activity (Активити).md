## Что за жизненный цикл Activity?
Жизненный цикл Activity в Android (ЖЦ) — это последовательность состояний, через которые проходит активити от момента её создания до уничтожения. 

При использовании приложения мы постоянно перемещаемся от одного экрана к другому и обратно. Поэтому все активити, с которыми мы взаимодействуем постоянно меняют состояние своего жизненного цикла. А чтобы узнать о смене состояния существуют методы обратного вызова. Т.е. как только активити перешла в другое состояние, сразу же вызывается соответствующий метод обратного вызова. Таким образом можно отслеживать смену состояния и реагировать на него.

Понимание жизненного цикла необходимо для:
* Правильного управления ресурсами. Освобождение и повторная инициализация ресурсов в нужные моменты предотвращают утечки памяти и снижают нагрузку на систему.
* Сохранения состояния приложения. Методы жизненного цикла помогают сохранить текущее состояние пользовательского интерфейса и данных при изменении конфигурации. Например, поворот экрана, смена темы устройства.
* Обеспечения плавного пользовательского опыта. Корректное управление жизненным циклом позволяет избежать зависаний и сбоев, делая приложение более отзывчивым и стабильным.
* Отладки и тестирования. Знание жизненного цикла упрощает процесс отладки и написания тестов, так как разработчики могут точно определить, когда происходят сбои или ошибки.


Представим, что наш экран активен, и в какой-то момент мы переходим на другой экран или просто закрываем приложение, что происходит в этот момент с Activity? </br> 
У неё меняется стадия ЖЦ.

## Какие стадии ЖЦ есть?

Рассмотрим так всеми любимую иллюстрацию схемы ЖЦ:
![2.png](..%2Fall_images%2F2.png)
Методы-колбэки на схеме обозначены прямоугольниками. Эти методы мы можем переопределять в классах наследниках от Activity.
Рассмотрим какие есть колбэки: 


`onCreate():` <br>
* вызывается, когда Activity создается;
* обычно в нем инициализируется интерфейс, некоторые ресурсы, восстанавливается состояние.

`onStart():` <br>
* вызывается, когда Activity становится видимой;
* в этом методе мы подготавливаем Activity к показу пользователю.

`onResume():` <br>
* вызывается, когда Activity становится доступной для взаимодействия с пользователем (начинают обрабатываться клики, жесты и т. д.);
* в этом методе запускаем интерактивные процессы, такие как воспроизведение анимации.

`onPause():` <br>
* вызывается, когда Activity становится недоступна для взаимодействия, но все еще видна;
* в этом методе останавливаем анимации и другие интерактивные процессы.

`onStop():` <br>
* вызывается, когда Activity перестает быть видна;
* в этом методе освобождаем ресурсы, которые не нужны на время, пока Acitivity не видна.

`onRestart():` <br>
* вызывается перед тем, как Activity снова станет видна;
* обычно не переопределяется.

`onDestroy():` <br>
* вызывается перед уничтожением Activity;
* в этом методе очищаем все оставшиеся ресурсы.


Разработчики сами определяют, какие методы ЖЦ необходимо переопределить.
Во многих случаях достаточно переопределить только метод `onCreate`.

## Рассмотрим подробнее

<hr>

### **1. onCreate():** <br>
Это — один из ключевых методов жизненного цикла Activity в Android. Он вызывается системой, когда создаётся экземпляр активности, и он является первой точкой входа для инициализации приложения.
<br> Метод `onCreate()` вызывается один раз при создании активности, до того как пользователь сможет взаимодействовать с интерфейсом.
<br> В этот момент мы можем инициализировать все важные компоненты активности, например:
* Установить макет с помощью `setContentView()`.
* Инициализация UI-компонентов (кнопки, текстовые поля и т.д.).
* Настройка состояния активности, например, загрузка данных или настройка `listeners` (слушателей действий, например нажатия на кнопку).

Рассмотрим пример простейшего переопределения метода `onCreate()`
``` kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Устанавливаем макет активности
        setContentView(R.layout.activity_main)

        // Инициализация кнопки и установка слушателя
        val button: Button = findViewById(R.id.button_generate)
        button.setOnClickListener {
            // Действие при нажатии кнопки
            Toast.makeText(this, "Кнопка нажата", Toast.LENGTH_SHORT).show()
        }

        // Восстановление состояния активности
        if (savedInstanceState != null) {
            val savedValue = savedInstanceState.getString("KEY_SAVED_DATA")
            // Используем сохранённые данные
        }
    }
}
```
**Объект Bundle.**
* Заметим, что метод принимает объект класса `Bundle`, который может быть и `null`.
Изначально, при самом первом запуске приложения, он `null`. 
<br> Но, если передается не `null` объект `savedInstanceState`, то это значит, что активити перезапускается, 
и в этом объекте содержатся сохранённые данные, 
такие как состояние UI или другие важные данные. 
Их можно использовать для восстановления активности в нужном состоянии.

**setContentView():** 
* Один из наиболее важных вызовов в onCreate(). 
Он связывает XML-макет с активностью, создавая UI.

**Инициализация состояния и данных:**
* onCreate() используется для загрузки данных, например, инициализации ViewModel, 
настройки адаптеров RecyclerView и т.д.

<hr>

### **2. onStart():** <br>
Метод `onStart()` — второй этап в жизненном цикле Activity в Android, который вызывается после метода `onCreate()`
<br> Он вызывается, когда активити становится видимой для пользователя, 
но еще не готова к взаимодействию. 
На этом этапе активити уже загружена в память и отображает интерфейс,
но она еще не получила фокус для взаимодействия (это произойдет в `onResume()`)

Этот метод обычно используется для выполнения задач, 
которые должны быть активны, пока активити видима, 
но которые не требуют непосредственного взаимодействия с пользователем. Например:

* Запуск анимаций.
* Настройка слушателей или подписка на события.
* Начало процессов, которые не требуют активного взаимодействия пользователя, 
но должны обновляться в видимой активности (например, обновление данных интерфейса).

Рассмотрим пример простейшего переопределения метода onStart()
``` kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    override fun onStart() {
        super.onStart()
        // активити становится видимой
        Log.d("MainActivity", "onStart вызван")

        // Например, можно запустить анимацию
        startAnimation()
    }

    private fun startAnimation() {
        // Логика анимации
    }
}
```
В данном примере метод `onStart()` вызывается после инициализации интерфейса, и мы запускаем анимацию.

**Жизненный цикл активности:**
* `onStart()` вызывается каждый раз, когда активити становится видимой, будь то при её первом запуске или при возвращении к активности после сворачивания приложения.
* Если пользователь минимизирует приложение, а затем возвращается, то активити снова вызовет `onStart()`.

**Реакция на действия пользователя:** \
Метод не подразумевает взаимодействие пользователя с приложением — оно еще не активно для ввода. 
Только в `onResume()` активити получает полный фокус для взаимодействия.

**Время выполнения фоновых задач:** \
Этот метод полезен для инициализации элементов, которые будут активны, пока активити видна. 
Например, запуск потоков для обновления данных или настройка наблюдателей для LiveData.

**Прерывание активности:** \
Если пользователь уходит с активности (например, вызывает другое приложение), но не закрывает её полностью, при возвращении к активности снова будет вызван onStart(), чтобы подготовить её к отображению.

<hr>

### **3. onResume():** <br>

Метод `onResume()` — один из важнейших методов жизненного цикла активности в Android, 
который вызывается после onStart() и передает активити в состояние полной готовности 
для взаимодействия с пользователем.

Метод `onResume()` вызывается, когда активити становится активной и готовой к
взаимодействию с пользователем. В этот момент она получает фокус и начинает обрабатывать пользовательский 
ввод (клавиатура, касания экрана и т.д.).

Этот метод вызывается каждый раз, когда пользователь возвращается к активности, 
будь то при первом запуске или при возобновлении работы приложения после сворачивания. 
В этом состоянии активити находится на переднем плане и отображается на экране.

Рассмотрим пример простейшего переопределения метода `onStart()`
``` kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    override fun onStart() {
        super.onStart()
        // активити становится видимой
    }

    override fun onResume() {
        super.onResume()
        // активити готова для взаимодействия
        Log.d("MainActivity", "onResume вызван")

        // Например, можно возобновить обновление интерфейса или подписаться на события
        resumeUpdates()
    }

    private fun resumeUpdates() {
        // Логика возобновления данных или обновления интерфейса
    }
}
```

В этом примере метод `onResume()` используется для возобновления обновлений интерфейса или других действий, 
которые должны выполняться, когда активити находится на переднем плане.

**Полная готовность к взаимодействию:** \
После вызова `onResume()` активити становится готовой для взаимодействия с пользователем. 
Это идеальный момент для возобновления любых процессов, которые были приостановлены, например:
* Воспроизведение видео или аудио.
* Обновление данных или интерфейса в реальном времени.
* Включение камер или других сенсоров.

**Остановка активности:** \
Когда активити покидает передний план (например, при сворачивании приложения или при переходе к другой активности),
будет вызван метод `onPause()`, чтобы приостановить действия, требующие активного взаимодействия с пользователем.

**Повторные вызовы:** \
Каждый раз, когда пользователь возвращается к активности (например, после сворачивания приложения), 
метод onResume() вызывается снова. Это позволяет вам возобновить все процессы, которые должны быть активны, 
пока пользователь взаимодействует с приложением.

### Советы:

* В методе `onResume()` не стоит выполнять тяжелые операции, 
такие как загрузка больших данных или сложные вычисления. 
Эти операции должны быть выполнены в `onCreate()` или `onStart()`, чтобы не замедлять интерфейс.
 
* Если вдруг нужно приостановить процессы, когда активность уходит на задний план (например, видео, аудио, подписки на события), 
их нужно останавливать в `onPause()` и возобновлять в `onResume()`.

### **4. onPause():** <br>
Метод `onPause()` — это часть жизненного цикла активности Android, который вызывается, когда активность перестаёт быть на переднем плане, но ещё видима или частично скрыта другим окном (например, диалоговым окном).

Назначение и вызов метода
Метод `onPause()` вызывается, когда активность уходит на задний план. Это может произойти в разных ситуациях:

* Пользователь открывает другую активность в приложении.
* Пользователь сворачивает приложение (например, нажимает кнопку «Домой»).
* Открывается системное уведомление или диалоговое окно.

Этот метод используется для приостановки любых процессов, которые требуют активного взаимодействия с пользователем или могут замедлить приложение, когда активность не видна на переднем плане.

Рассмотрим пример простейшего переопределения метода onStart()
``` kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    override fun onResume() {
        super.onResume()
        // Возобновляем активные действия, например, обновление интерфейса
    }

    override fun onPause() {
        super.onPause()
        // Приостанавливаем действия, которые требуют полного фокуса
        Log.d("MainActivity", "onPause вызван")

        // Пример: остановка воспроизведения видео
        pauseVideo()

        // Пример: приостановка слушателей или сохранение данных
        saveAppState()
    }

    private fun pauseVideo() {
        // Остановка воспроизведения видео
    }

    private fun saveAppState() {
        // Сохранение состояния приложения
    }
}

```

В данном примере метод `onPause()` используется для приостановки 
воспроизведения видео и сохранения состояния приложения, 
чтобы не терять данные, если пользователь покинет приложение.

**Остановка процессов, связанных с UI:** \
В `onPause()` приостанавливаются любые действия, которые не должны продолжаться, если активность больше не на переднем плане. Например:

* Остановка анимаций.
* Остановка воспроизведения аудио или видео.
* Приостановка обновлений интерфейса в реальном времени.

**Сохранение данных:** \
Это хороший момент для сохранения данных, если активность может быть уничтожена системой (например, при нехватке памяти) 
до того, как будет вызван `onStop()` или `onDestroy()`. 
Это может включать:

* Сохранение черновиков (например, в приложении заметок).
* Сохранение текущего состояния интерфейса.

**Асинхронные задачи:** Если у вас есть активные асинхронные задачи, такие как запросы в сеть или операции с базой данных, их также можно приостановить в `onPause()`. Продолжение таких задач в фоне может быть нежелательно, так как они могут нагружать систему.

**Переход в другие состояния:** После вызова `onPause()` активность может вернуться в `onResume()`, если пользователь быстро вернётся к ней, либо перейти в `onStop()`, если приложение больше не видно.

**Производительность:** При вызове метода `onPause()` система может уничтожить приложение, если ресурсы системы становятся ограниченными. Это делает `onPause()` критически важным для управления ресурсами и предотвращения потерь данных.

**Когда используется onPause()?** 
* `Остановка мультимедиа:` Прекращение воспроизведения видео или аудио.
* `Сохранение состояния:` Чтобы сохранить текущее состояние активности перед её возможным уничтожением.
* `Отмена подписок или слушателей:` Например, отписка от обновлений в реальном времени или приостановка отслеживания данных от сенсоров устройства.
* `Уменьшение нагрузки:` Снижение использования ресурсов, когда активность не активна (например, отключение ненужных фоновых процессов). 

Метод `onPause()` служит для подготовки активности к выходу из активного состояния и управлению её поведением в моменты, когда она временно не используется.